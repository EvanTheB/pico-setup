#!/usr/bin/env bash

# Executes the full test suite on the local host
#
# Configurations env vars:

set -ex

WORKING_DIR="$(pwd)/pico"

linux() {
    # Returns true iff this is running on Linux
    uname | grep -q "^Linux$"
    return ${?}
}

debian() {
    # Returns true iff this is running on Debian
    grep -q '^NAME="Debian GNU/Linux"$' /etc/os-release
    return ${?}
}

ubuntu() {
    # Returns true iff this is running on Ubuntu
    grep -q '^NAME="Ubuntu"$' /etc/os-release
    return ${?}
}

mac() {
    # Returns true iff this is running on macOS and presumably Apple hardware
    uname | grep -q "^Darwin$"
    return ${?}
}

raspberry_pi() {
    # Returns true iff this is running on a Raspberry Pi computer, regardless of the OS
    if [ -f /proc/cpuinfo ]; then
        grep -q "^Model\s*: Raspberry Pi" /proc/cpuinfo
        return ${?}
    fi
    return 1
}


fail() {
    # Outputs a failure message and exits with the error code output by the previous call.
    # All args are echoed as a failure message.

    R="${?}"
    echo "Tests failed! :'-("
    if [ ${*} ]; then
        echo "${*}"
    fi
    exit ${R}
}

test_git_repo() {
    # tests that the given relative path exists and is a git repo
    git -C ${WORKING_DIR}/${1} status || fail
}

test_toolchain_linux() {
    # test that the expected packages are installed
    dpkg-query -s git cmake gcc-arm-none-eabi build-essential gdb-multiarch automake autoconf build-essential texinfo libtool libftdi-dev libusb-1.0-0-dev || fail
}

test_toolchain_mac() {
    # test that the expected packages are installed
    brew list git cmake pkg-config libtool automake libusb wget pkg-config gcc texinfo arm-none-eabi-gcc
}

test_pico_sdk() {
    test_git_repo pico-sdk

    # test that the SDK env var is set and correct
    test "${PICO_SDK_PATH}" = "${WORKING_DIR}/pico-sdk" || fail
}

test_uart() {
    # test that the UART is configured. Only works on Raspberry Pi OS on Raspberry Pi hardware.
    dpkg-query -s minicom || fail
    grep -q "enable_uart=1" /boot/config.txt || fail
    # note that the test for console=serial0 tests for the absence of a string
    grep -q "console=serial0" /boot/cmdline.txt && fail
}

test_pico_examples() {
    test_git_repo pico-examples

    # test that blink is built
    test -f ${WORKING_DIR}/pico-examples/build/blink/blink.uf2 || fail

    # test that hello_serial is built
    test -f ${WORKING_DIR}/pico-examples/build/hello_world/serial/hello_serial.uf2 || fail

    # test that hello_usb is built
    test -f ${WORKING_DIR}/pico-examples/build/hello_world/usb/hello_usb.uf2 || fail
}

test_pico_extras() {
    test_git_repo pico-extras
}

test_pico_playground() {
    test_git_repo pico-playground
}

test_picotool() {
    test_git_repo picotool

    # test that the binary is built
    test -x ${WORKING_DIR}/picotool/build/picotool || fail

    # test that picotool is installed in the expected location
    test -x /usr/local/bin/picotool || fail
}

test_openocd() {
    test_git_repo openocd

    # test that the binary is built
    test -x ${WORKING_DIR}/openocd/src/openocd || fail
}

test_picoprobe() {
    test_git_repo picoprobe || fail

    # test that the binary is built
    test -f ${WORKING_DIR}/picoprobe/build/picoprobe.uf2 || fail
}

test_vscode_linux() {
    dpkg-query -s code || fail
}

test_vscode_mac() {
    echo "Not yet implemented: testing Visual Studio Code on macOS"
}


# execute tests
if mac; then
    test_toolchain_mac
else
    test_toolchain_linux
fi

test_pico_sdk

if raspbian && raspberry_pi; then
    test_uart
fi

test_pico_examples
test_pico_extras
test_pico_playground
test_openocd
test_picoprobe
test_picotool
if mac; then
    test_vscode_mac
else
    if dpkg-query -s xserver-xorg >> /dev/null && ! (debian || ubuntu); then
        test_vscode_linux
    fi
fi

echo "Tests passed! :D"
